// Copyright Voxel Plugin, Inc. All Rights Reserved.

#include "VoxelGraphMacroNode.h"
#include "VoxelExec.h"
#include "VoxelInlineGraph.h"
#include "VoxelGraph.h"
#include "VoxelGraphToolkit.h"
#include "VoxelMacroLibrary.h"
#include "VoxelGraphInstance.h"
#include "VoxelGraphInterfaceToolkit.h"
#include "VoxelGraphMacroParameterNode.h"
#include "Toolkits/ToolkitManager.h"

void UVoxelGraphMacroNode::AllocateDefaultPins()
{
	DelegateRef = MakeVoxelShared<int32>();

	if (!GraphInterface)
	{
		return;
	}

	if (UVoxelGraphInstance* Instance = Cast<UVoxelGraphInstance>(GraphInterface))
	{
		const TSharedRef<UVoxelGraph*> LastGraph = MakeSharedCopy(Instance->GetGraph());
		Instance->AddOnChanged(MakeWeakPtrDelegate(DelegateRef, [this, LastGraph, Instance = MakeWeakObjectPtr(Instance)]
		{
			if (!ensure(Instance.IsValid()))
			{
				return;
			}

			UVoxelGraph* Graph = Instance->GetGraph();
			if (*LastGraph == Graph)
			{
				return;
			}
			*LastGraph = Graph;

			ReconstructNode();

			const TSharedPtr<FVoxelGraphToolkit> Toolkit = GetToolkit();
			if (!ensure(Toolkit))
			{
				return;
			}

			Toolkit->OnGraphChanged(GetGraph());
		}));
	}

	const UVoxelGraph* Graph = GraphInterface->GetGraph();
	if (!Graph)
	{
		return;
	}

	Graph->OnParametersChanged.Add(MakeWeakPtrDelegate(DelegateRef, [this](UVoxelGraph::EParameterChangeType)
	{
		ReconstructNode();

		const TSharedPtr<FVoxelGraphToolkit> Toolkit = GetToolkit();
		if (!ensure(Toolkit))
		{
			return;
		}

		Toolkit->OnGraphChanged(GetGraph());
	}));

	CachedOptionalPins.Reset();

	if (Type == EVoxelGraphMacroType::RecursiveTemplate)
	{
		// TODO HACK
		Type = EVoxelGraphMacroType::Template;
	}

	switch (Type)
	{
	default: ensure(false);
	case EVoxelGraphMacroType::Macro: break;
	case EVoxelGraphMacroType::Template:
	{
		UEdGraphPin* Pin = CreatePin(
			EGPD_Input,
			FVoxelPinType::Make<FVoxelInlineGraph>().GetEdGraphPinType(),
			FVoxelNodeNames::MacroTemplateInput);

		Pin->PinFriendlyName = INVTEXT("Graph");
	}
	break;
	case EVoxelGraphMacroType::RecursiveTemplate:
	{
		UEdGraphPin* Pin = CreatePin(
			EGPD_Input,
			FVoxelPinType::Make<FVoxelInlineGraph>().GetBufferType().GetEdGraphPinType(),
			FVoxelNodeNames::MacroRecursiveTemplateInput);

		Pin->PinFriendlyName = INVTEXT("Graphs");
	}
	break;
	}

	for (const FVoxelGraphParameter& Parameter : Graph->Parameters)
	{
		if (Parameter.ParameterType != EVoxelGraphParameterType::Input &&
			Parameter.ParameterType != EVoxelGraphParameterType::Output)
		{
			continue;
		}

		const FName PinUniqueName = *Parameter.Guid.ToString();

		UEdGraphPin* GraphPin = CreatePin(
			Parameter.ParameterType == EVoxelGraphParameterType::Input ? EGPD_Input : EGPD_Output,
			Parameter.Type.GetEdGraphPinType(),
			PinUniqueName);

		GraphPin->PinFriendlyName = FText::FromName(Parameter.Name);

		if (Parameter.ParameterType != EVoxelGraphParameterType::Input)
		{
			continue;
		}

		if (!ensure(Graph->MainEdGraph))
		{
			continue;
		}

		for (const UEdGraphNode* Node : Graph->MainEdGraph->Nodes)
		{
			if (!Node->IsA<UVoxelGraphMacroParameterInputNode>())
			{
				continue;
			}

			const UVoxelGraphMacroParameterInputNode* MacroNode = CastChecked<UVoxelGraphMacroParameterInputNode>(Node);
			if (MacroNode->Guid != Parameter.Guid ||
				!MacroNode->bExposeDefaultPin)
			{
				continue;
			}

			CachedOptionalPins.Add(GraphPin);
			break;
		}

		if (Parameter.DefaultValue.GetType().HasPinDefaultValue())
		{
			Parameter.DefaultValue.ApplyToPinDefaultValue(*GraphPin);
			GraphPin->AutogeneratedDefaultValue = GraphPin->DefaultValue;
		}
	}

	Super::AllocateDefaultPins();
}

FText UVoxelGraphMacroNode::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	if (!GraphInterface)
	{
		return INVTEXT("Empty");
	}

	return FText::FromString(GraphInterface->GetGraphName());
}

FLinearColor UVoxelGraphMacroNode::GetNodeTitleColor() const
{
	if (!GraphInterface)
	{
		return FLinearColor::Gray;
	}

	const UVoxelGraph* Graph = GraphInterface->GetGraph();
	if (!Graph)
	{
		return FLinearColor::Gray;
	}

	return Graph->InstanceColor;

}

FText UVoxelGraphMacroNode::GetTooltipText() const
{
	if (!GraphInterface)
	{
		return {};
	}

	const UVoxelGraph* Graph = GraphInterface->GetGraph();
	if (!Graph)
	{
		return {};
	}

	return FText::FromString(Graph->Tooltip);
}

FSlateIcon UVoxelGraphMacroNode::GetIconAndTint(FLinearColor& OutColor) const
{
	static FSlateIcon Icon("EditorStyle", "GraphEditor.Macro_16x");
	return Icon;
}

bool UVoxelGraphMacroNode::IsPinOptional(const UEdGraphPin& Pin) const
{
	return CachedOptionalPins.Contains(&Pin);
}

void UVoxelGraphMacroNode::JumpToDefinition() const
{
	if (!GraphInterface)
	{
		return;
	}

	if (GraphInterface->IsA<UVoxelGraphInstance>())
	{
		FVoxelToolkit::OpenToolkit<FVoxelGraphInterfacePreviewToolkit>(GraphInterface);
		return;
	}

	UVoxelGraphInterface* AssetToOpen = GraphInterface;
	if (AssetToOpen != GraphInterface->GetOutermostObject())
	{
		UObject* OuterAsset = GraphInterface->GetOutermostObject();
		if (const UVoxelMacroLibrary* MacroLibrary = Cast<UVoxelMacroLibrary>(OuterAsset))
		{
			AssetToOpen = MacroLibrary->Graph;
		}
		else if (UVoxelGraph* GraphAsset = Cast<UVoxelGraph>(OuterAsset))
		{
			AssetToOpen = GraphAsset;
		}
		else
		{
			ensure(false);
			return;
		}
	}

	const FVoxelGraphToolkit* Toolkit = FVoxelToolkit::OpenToolkit<FVoxelGraphToolkit>(AssetToOpen);
	if (!ensure(Toolkit))
	{
		return;
	}

	const UVoxelGraph* Graph = GraphInterface->GetGraph();
	if (!ensure(Graph))
	{
		return;
	}

	Toolkit->OpenGraphAndBringToFront(Graph->MainEdGraph, true);
}

FName UVoxelGraphMacroNode::GetPinCategory(const UEdGraphPin& Pin) const
{
	if (Pin.PinName == FVoxelNodeNames::MacroTemplateInput ||
		Pin.PinName == FVoxelNodeNames::MacroRecursiveTemplateInput)
	{
		return {};
	}

	FGuid Guid;
	if (!ensure(FGuid::Parse(Pin.GetName(), Guid)))
	{
		return {};
	}

	if (!ensure(GraphInterface))
	{
		return {};
	}

	UVoxelGraph* Graph = GraphInterface->GetGraph();
	if (!ensure(Graph))
	{
		return {};
	}

	const FVoxelGraphParameter* Parameter = Graph->FindParameterByGuid(Guid);
	if (!ensure(Parameter))
	{
		return {};
	}

	return *Parameter->Category;
}

TSharedRef<IVoxelNodeDefinition> UVoxelGraphMacroNode::GetNodeDefinition()
{
	return MakeVoxelShared<FVoxelGraphMacroNodeDefinition>(*this);
}

void UVoxelGraphMacroNode::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	if (PropertyChangedEvent.GetMemberPropertyName() == GET_OWN_MEMBER_NAME(GraphInterface))
	{
		ReconstructNode();
	}

	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.GetMemberPropertyName() == GET_OWN_MEMBER_NAME(Type))
	{
		ReconstructNode();

		const TSharedPtr<FVoxelGraphToolkit> Toolkit = GetToolkit();
		if (ensure(Toolkit))
		{
			Toolkit->OnGraphChanged(GetGraph());
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

FVoxelGraphMacroNodeDefinition::FVoxelGraphMacroNodeDefinition(UVoxelGraphMacroNode& Node) : Node(Node)
{
}

TSharedPtr<const IVoxelNodeDefinition::FNode> FVoxelGraphMacroNodeDefinition::GetInputs() const
{
	return GetPins(true);
}

TSharedPtr<const IVoxelNodeDefinition::FNode> FVoxelGraphMacroNodeDefinition::GetOutputs() const
{
	return GetPins(false);
}

TSharedPtr<const IVoxelNodeDefinition::FNode> FVoxelGraphMacroNodeDefinition::GetPins(const bool bInput) const
{
	TSharedRef<FNode> Root = FNode::MakeCategory({}, {});

	if (!Node.GraphInterface)
	{
		return Root;
	}

	UVoxelGraph* Graph = Node.GraphInterface->GetGraph();
	if (!Graph)
	{
		return Root;
	}

	if (bInput)
	{
		Root->Children.Add(FNode::MakePin(FVoxelNodeNames::MacroTemplateInput, {}));
		Root->Children.Add(FNode::MakePin(FVoxelNodeNames::MacroRecursiveTemplateInput, {}));
	}

	TMap<FName, TSharedPtr<FNode>> MappedCategories;

	const auto FindOrAddCategory = [&MappedCategories](const TSharedPtr<FNode>& Parent, const FString& PathElement, const FName FullPath)
	{
		if (const TSharedPtr<FNode>& CategoryNode = MappedCategories.FindRef(FullPath))
		{
			return CategoryNode.ToSharedRef();
		}

		TSharedRef<FNode> Category = FNode::MakeCategory(FName(PathElement), FNode::MakePath(FullPath.ToString()));
		Parent->Children.Add(Category);
		MappedCategories.Add(FullPath, Category);

		return Category;
	};

	const EVoxelGraphParameterType TargetType = bInput ? EVoxelGraphParameterType::Input : EVoxelGraphParameterType::Output;

	TArray<FString> Categories = Graph->GetCategories(TargetType);
	for (const FString& FullCategory : Categories)
	{
		TArray<FName> Path = FNode::MakePath(FullCategory);
		if (Path.Num() == 0)
		{
			continue;
		}

		FString CurrentPath = Path[0].ToString();
		TSharedRef<FNode> ParentCategoryNode = FindOrAddCategory(Root, CurrentPath, FName(CurrentPath));

		for (int32 Index = 1; Index < Path.Num(); Index++)
		{
			CurrentPath += "|" + Path[Index].ToString();
			ParentCategoryNode = FindOrAddCategory(ParentCategoryNode, Path[Index].ToString(), FName(CurrentPath));
		}
	}

	for (const FVoxelGraphParameter& Parameter : Graph->Parameters)
	{
		if (Parameter.ParameterType != TargetType)
		{
			continue;
		}

		const FName ParameterName = *Parameter.Guid.ToString();

		if (Parameter.Category.IsEmpty())
		{
			Root->Children.Add(FNode::MakePin(ParameterName, {}));
			continue;
		}

		if (const TSharedPtr<FNode>& Category = MappedCategories.FindRef(FName(Parameter.Category)))
		{
			Category->Children.Add(FNode::MakePin(ParameterName, FNode::MakePath(Parameter.Category)));
			continue;
		}

		ensure(false);
		Root->Children.Add(FNode::MakePin(ParameterName, {}));
	}

	return Root;
}